{% comment %}
  Scripts pour le dropdown command palette dans la navbar
{% endcomment %}
<script>
// Composant Alpine.js pour le dropdown command palette
window.commandPaletteDropdown = function() {
  return {
    query: '',
    searchQuery: '',
    results: [],
    hasMore: false,
    totalCount: 0,
    offset: 0,
    open: false,
    loading: false,
    loadingMore: false,
    activeIndex: -1,
    abortController: null,
    _cachedItems: null,
    _cacheKey: '',

    // Highlight search term in text
    highlightMatch(text, query) {
      if (!text || !query) return text;
      const index = text.toLowerCase().indexOf(query.toLowerCase());
      if (index === -1) return text;

      const before = text.substring(0, index);
      const match = text.substring(index, index + query.length);
      const after = text.substring(index + query.length);

      return `${before}<mark class="bg-warning/30 font-semibold">${match}</mark>${after}`;
    },

    init() {
      // Reset activeIndex when opening dropdown
      this.$watch('open', (value) => {
        if (value) {
          this._cachedItems = null; // Clear cache when opening
          this.activeIndex = -1; // Start with no selection
        } else {
          this._cachedItems = null; // Clear cache when closing
        }
      });

      // Reset activeIndex, cache and offset when query changes
      this.$watch('query', () => {
        this._cachedItems = null;
        this.activeIndex = -1; // Reset to no selection
        this.offset = 0; // Reset pagination
      });

      // Clear cache when results array changes
      this.$watch('results', () => {
        this._cachedItems = null;
        this.activeIndex = -1; // Reset to no selection
      });
    },

    getAllItems() {
      if (!this.open) return [];

      // Create a cache key based on query and results length
      const cacheKey = `${this.query.length}-${this.results.length}`;

      // Return cached items if cache key matches
      if (this._cachedItems && this._cacheKey === cacheKey) {
        return this._cachedItems;
      }

      // Use $root to get the root element with x-data
      const root = this.$root;

      // Get all visible clickable links from the dropdown
      const allLinks = Array.from(root.querySelectorAll('a[href]'));

      // Filter out links that are hidden by x-show or in hidden parent containers
      const visibleLinks = allLinks.filter(el => {
        // Check if the element or any parent has display: none
        let current = el;
        while (current && current !== root) {
          const style = window.getComputedStyle(current);
          if (style.display === 'none') {
            return false;
          }
          current = current.parentElement;
        }
        return true;
      });

      // Cache the result
      this._cachedItems = visibleLinks;
      this._cacheKey = cacheKey;

      return visibleLinks;
    },

    async search() {
      const q = this.query.trim();

      if (q.length < 2) {
        this.results = [];
        this.hasMore = false;
        this.totalCount = 0;
        this.offset = 0;
        this.loading = false;
        return;
      }

      // Cancel previous request
      if (this.abortController) {
        this.abortController.abort();
      }
      this.abortController = new AbortController();

      this.loading = true;
      this.offset = 0;

      try {
        const response = await fetch(
          `/api/v1/person/search?q=${encodeURIComponent(q)}&limit=10&offset=0`,
          { signal: this.abortController.signal }
        );

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const data = await response.json();
        this.results = data.results || [];
        this.hasMore = data.has_more || false;
        this.totalCount = data.count || 0;
        this.offset = this.results.length;
        this.searchQuery = data.query || q;

        // Re-initialize Lucide icons
        LucideUtils.alpineNextTick(this);
      } catch (error) {
        if (error.name !== 'AbortError') {
          console.error('Search error:', error);
          this.results = [];
          this.hasMore = false;
          this.totalCount = 0;
        }
      } finally {
        this.loading = false;
        this.abortController = null;
      }
    },

    async loadMore() {
      if (!this.hasMore || this.loadingMore) return;

      const q = this.query.trim();
      if (q.length < 2) return;

      this.loadingMore = true;

      try {
        const response = await fetch(
          `/api/v1/person/search?q=${encodeURIComponent(q)}&limit=10&offset=${this.offset}`
        );

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const data = await response.json();
        this.results = [...this.results, ...(data.results || [])];
        this.hasMore = data.has_more || false;
        this.totalCount = data.count || 0;
        this.offset = this.results.length;

        // Re-initialize Lucide icons
        LucideUtils.alpineNextTick(this);
      } catch (error) {
        console.error('Load more error:', error);
      } finally {
        this.loadingMore = false;
      }
    },

    // Get the total count of navigable items based on current state
    getItemCount() {
      if (this.query.length >= 2) {
        // Search results mode
        return this.results.length;
      } else if (this.query.length === 0) {
        // Quick actions mode - 3 items (or 4 if admin, but we'll use DOM count as fallback)
        const quickActionsContainer = this.$root.querySelector('[x-show="query.length === 0"]');
        if (quickActionsContainer) {
          return quickActionsContainer.querySelectorAll('a[href]').length;
        }
        return 3; // Default fallback
      }
      return 0;
    },

    navigate(direction) {
      const itemCount = this.getItemCount();

      if (itemCount === 0) return;

      this.activeIndex += direction;

      // Wrap around
      if (this.activeIndex < 0) {
        this.activeIndex = itemCount - 1;
      } else if (this.activeIndex >= itemCount) {
        this.activeIndex = 0;
      }

      // Scroll into view
      this.$nextTick(() => {
        const allItems = this.getAllItems();
        const activeEl = allItems[this.activeIndex];
        if (activeEl) {
          activeEl.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        }
      });
    },

    select() {
      if (this.activeIndex < 0) return;

      const allItems = this.getAllItems();
      const activeEl = allItems[this.activeIndex];

      if (activeEl && activeEl.href) {
        activeEl.click();
      }
    },

    close() {
      this.open = false;
      this.activeIndex = -1;
      this.$refs.input?.blur(); // Remove focus from input
    },

    focus() {
      this.$refs.input?.focus();
      this.open = true;
    },

    setActiveFromElement(el) {
      this._cachedItems = null; // Force recalculation
      const items = this.getAllItems();
      const index = items.indexOf(el);
      if (index !== -1) {
        this.activeIndex = index;
      }
    },

    // Check if a result at the given index is active (for search results)
    isResultActive(index) {
      if (!this.open) return false;
      if (this.activeIndex < 0) return false;

      // Calculate the offset: quick actions come first when query is empty
      // When query has results, only results are shown
      if (this.query.length >= 2) {
        // Only search results are visible
        return this.activeIndex === index;
      }
      return false;
    },

    // Check if a quick action at the given index is active
    isQuickActionActive(index) {
      if (!this.open) return false;
      if (this.activeIndex < 0) return false;

      // Quick actions are only visible when query is empty
      if (this.query.length === 0) {
        return this.activeIndex === index;
      }
      return false;
    },

    isActive(el) {
      // Don't use cache for isActive to ensure reactivity
      if (!this.open) return false;
      if (this.activeIndex < 0) return false; // No selection

      const root = this.$root;
      const allLinks = Array.from(root.querySelectorAll('a[href]'));
      const visibleLinks = allLinks.filter(link => {
        let current = link;
        while (current && current !== root) {
          const style = window.getComputedStyle(current);
          if (style.display === 'none') return false;
          current = current.parentElement;
        }
        return true;
      });

      return visibleLinks.indexOf(el) === this.activeIndex;
    }
  };
};

// Global keyboard shortcut Ctrl+K to focus the search
document.addEventListener('keydown', function(e) {
  if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
    e.preventDefault();

    // Find the search input
    const searchInput = document.querySelector('[x-data*="commandPaletteDropdown"]')?.querySelector('input');
    if (searchInput) {
      searchInput.focus();
      searchInput.select();
    }
  }
});
</script>
