from rest_framework import serializers
from drf_spectacular.types import OpenApiTypes
from drf_spectacular.utils import extend_schema_field

from .models import File, FileComment, FileFavorite, FileShare, PinnedFolder
from workspace.files.services import FileService


class FileSerializer(serializers.ModelSerializer):
    is_folder = serializers.SerializerMethodField(
        help_text="True when node_type is 'folder'."
    )
    is_file = serializers.SerializerMethodField(
        help_text="True when node_type is 'file'."
    )
    is_favorite = serializers.SerializerMethodField(
        help_text="True when the current user has favorited this item."
    )
    category = serializers.SerializerMethodField(
        help_text="File category (text, image, pdf, video, audio, unknown)."
    )
    is_viewable = serializers.SerializerMethodField(
        help_text="True if file can be viewed in browser."
    )
    content_url = serializers.SerializerMethodField(
        help_text="URL to fetch file content for viewing."
    )
    is_pinned = serializers.SerializerMethodField(
        help_text="True when the current user has pinned this folder to the sidebar."
    )
    is_shared = serializers.SerializerMethodField(
        help_text="True when the file has been shared with at least one user."
    )

    class Meta:
        model = File
        fields = [
            'uuid',
            'name',
            'node_type',
            'parent',
            'content',
            'size',
            'mime_type',
            'icon',
            'color',
            'owner',
            'created_at',
            'updated_at',
            'deleted_at',
            'path',
            'is_folder',
            'is_file',
            'is_favorite',
            'category',
            'is_viewable',
            'content_url',
            'is_pinned',
            'is_shared',
        ]
        read_only_fields = ['owner', 'created_at', 'updated_at', 'deleted_at', 'size', 'path', 'is_favorite', 'is_pinned', 'is_shared']
        extra_kwargs = {
            'uuid': {
                'help_text': 'Unique identifier. Generated by the server if omitted.'
            },
            'name': {'help_text': 'Display name of the file or folder.'},
            'node_type': {'help_text': "Either 'file' or 'folder'."},
            'parent': {'help_text': 'Parent folder UUID.'},
            'content': {
                'help_text': 'File payload. Must be empty for folders.',
                'allow_empty_file': True,
                'required': False,
                'write_only': True,
            },
            'size': {'help_text': 'File size in bytes.'},
            'mime_type': {'help_text': 'MIME type for file nodes.'},
            'owner': {'help_text': 'Owner user id.'},
            'created_at': {'help_text': 'Creation timestamp.'},
            'updated_at': {'help_text': 'Last update timestamp.'},
        }

    @extend_schema_field(OpenApiTypes.BOOL)
    def get_is_folder(self, obj):
        return obj.is_folder()

    @extend_schema_field(OpenApiTypes.BOOL)
    def get_is_file(self, obj):
        return obj.is_file()

    @extend_schema_field(OpenApiTypes.BOOL)
    def get_is_favorite(self, obj):
        annotated = getattr(obj, 'is_favorite', None)
        if annotated is not None:
            return bool(annotated)
        request = self.context.get('request')
        if not request or not getattr(request, 'user', None) or not request.user.is_authenticated:
            return False
        return FileFavorite.objects.filter(owner=request.user, file=obj).exists()

    @extend_schema_field(OpenApiTypes.STR)
    def get_category(self, obj):
        from .utils import FileTypeDetector

        if obj.node_type != File.NodeType.FILE:
            return None
        return FileTypeDetector.categorize(obj.mime_type or '').value

    @extend_schema_field(OpenApiTypes.BOOL)
    def get_is_viewable(self, obj):
        from .utils import FileTypeDetector

        if obj.node_type != File.NodeType.FILE:
            return False
        return FileTypeDetector.is_viewable(obj.mime_type or '')

    @extend_schema_field(OpenApiTypes.STR)
    def get_content_url(self, obj):
        if obj.node_type == File.NodeType.FILE and obj.content:
            return f'/api/v1/files/{obj.uuid}/content'
        return None

    @extend_schema_field(OpenApiTypes.BOOL)
    def get_is_pinned(self, obj):
        if obj.node_type != File.NodeType.FOLDER:
            return False
        annotated = getattr(obj, 'is_pinned', None)
        if annotated is not None:
            return bool(annotated)
        request = self.context.get('request')
        if not request or not getattr(request, 'user', None) or not request.user.is_authenticated:
            return False
        return PinnedFolder.objects.filter(owner=request.user, folder=obj).exists()

    @extend_schema_field(OpenApiTypes.BOOL)
    def get_is_shared(self, obj):
        annotated = getattr(obj, 'is_shared', None)
        if annotated is not None:
            return bool(annotated)
        return FileShare.objects.filter(file=obj).exists()

    def validate(self, attrs):
        if self.instance is not None:
            errors = {}
            initial_data = self.initial_data or {}

            if 'uuid' in initial_data:
                incoming_uuid = str(initial_data.get('uuid')).lower()
                if incoming_uuid != str(self.instance.uuid).lower():
                    errors['uuid'] = 'This field is immutable.'

            if 'owner' in initial_data:
                incoming_owner = str(initial_data.get('owner'))
                if incoming_owner != str(self.instance.owner_id):
                    errors['owner'] = 'This field is immutable.'

            if 'node_type' in initial_data:
                if str(initial_data.get('node_type')) != self.instance.node_type:
                    errors['node_type'] = 'This field is immutable.'

            if errors:
                raise serializers.ValidationError(errors)

        node_type = attrs.get('node_type')
        instance = self.instance
        if instance is not None and node_type is None:
            node_type = instance.node_type

        # Validate parent assignment via FileService
        if 'parent' in attrs and instance is not None:
            try:
                FileService.validate_move_target(instance, attrs['parent'])
            except ValueError as e:
                raise serializers.ValidationError({'parent': e.args[0]})

        # Validate file name uniqueness via FileService
        if node_type == File.NodeType.FILE:
            name = attrs.get('name') or (instance.name if instance else None)
            parent = attrs.get('parent') if 'parent' in attrs else (instance.parent if instance else None)
            owner = instance.owner if instance else self.context['request'].user
            if name:
                try:
                    FileService.check_name_available(
                        owner, parent, name, node_type,
                        exclude_pk=instance.pk if instance else None,
                    )
                except ValueError as e:
                    raise serializers.ValidationError({'name': e.args[0]})

        return super().validate(attrs)

    def create(self, validated_data):
        validated_data['owner'] = self.context['request'].user
        if validated_data.get('node_type') == File.NodeType.FILE:
            uploaded = validated_data.get('content')
            if uploaded is not None:
                validated_data['size'] = uploaded.size
                if not validated_data.get('mime_type'):
                    validated_data['mime_type'] = FileService.infer_mime_type(
                        validated_data.get('name'),
                        uploaded=uploaded,
                    )
        else:
            validated_data['size'] = None
        return super().create(validated_data)

    def update(self, instance, validated_data):
        # Handle content update
        if 'content' in validated_data:
            uploaded = validated_data.get('content')
            if instance.node_type == File.NodeType.FILE and uploaded is not None:
                validated_data['size'] = uploaded.size
                if not validated_data.get('mime_type'):
                    validated_data['mime_type'] = FileService.infer_mime_type(
                        validated_data.get('name', instance.name),
                        uploaded=uploaded,
                    )
            else:
                validated_data['size'] = None

        # Handle rename via FileService (storage moves)
        if 'name' in validated_data:
            new_name = validated_data['name']
            if instance.name != new_name:
                FileService.rename(instance, new_name)
                # rename() already sets instance.name and saves,
                # but super().update() will set it again from validated_data
                # which is fine since it's the same value now.

        # Handle move via FileService (storage moves)
        if 'parent' in validated_data:
            new_parent = validated_data['parent']
            old_parent_id = instance.parent_id
            new_parent_id = new_parent.pk if new_parent else None
            if old_parent_id != new_parent_id:
                FileService.move(instance, new_parent)

        return super().update(instance, validated_data)


class FileCommentAuthorSerializer(serializers.Serializer):
    id = serializers.IntegerField(source='pk')
    username = serializers.CharField()
    first_name = serializers.CharField()
    last_name = serializers.CharField()
    avatar_url = serializers.SerializerMethodField()

    @extend_schema_field(OpenApiTypes.STR)
    def get_avatar_url(self, obj):
        return f'/api/v1/users/{obj.pk}/avatar'


class FileCommentSerializer(serializers.ModelSerializer):
    author = FileCommentAuthorSerializer(read_only=True)

    class Meta:
        model = FileComment
        fields = ['uuid', 'file', 'author', 'body', 'edited_at', 'created_at', 'deleted_at']
        read_only_fields = ['uuid', 'file', 'author', 'edited_at', 'created_at', 'deleted_at']


class FileCommentCreateSerializer(serializers.Serializer):
    body = serializers.CharField()


class FileCommentEditSerializer(serializers.Serializer):
    body = serializers.CharField()
