import mimetypes

from rest_framework import serializers
from drf_spectacular.types import OpenApiTypes
from drf_spectacular.utils import extend_schema_field
from .models import File, FileFavorite


class FileSerializer(serializers.ModelSerializer):
    is_folder = serializers.SerializerMethodField(
        help_text="True when node_type is 'folder'."
    )
    is_file = serializers.SerializerMethodField(
        help_text="True when node_type is 'file'."
    )
    is_favorite = serializers.SerializerMethodField(
        help_text="True when the current user has favorited this item."
    )
    category = serializers.SerializerMethodField(
        help_text="File category (text, image, pdf, video, audio, unknown)."
    )
    is_viewable = serializers.SerializerMethodField(
        help_text="True if file can be viewed in browser."
    )
    content_url = serializers.SerializerMethodField(
        help_text="URL to fetch file content for viewing."
    )

    class Meta:
        model = File
        fields = [
            'uuid',
            'name',
            'node_type',
            'parent',
            'content',
            'size',
            'mime_type',
            'owner',
            'created_at',
            'updated_at',
            'deleted_at',
            'path',
            'is_folder',
            'is_file',
            'is_favorite',
            'category',
            'is_viewable',
            'content_url',
        ]
        read_only_fields = ['owner', 'created_at', 'updated_at', 'deleted_at', 'size', 'path', 'is_favorite']
        extra_kwargs = {
            'uuid': {
                'help_text': 'Unique identifier. Generated by the server if omitted.'
            },
            'name': {'help_text': 'Display name of the file or folder.'},
            'node_type': {'help_text': "Either 'file' or 'folder'."},
            'parent': {'help_text': 'Parent folder UUID.'},
            'content': {
                'help_text': 'File payload. Must be empty for folders.',
                'allow_empty_file': True,
                'required': False,
            },
            'size': {'help_text': 'File size in bytes.'},
            'mime_type': {'help_text': 'MIME type for file nodes.'},
            'owner': {'help_text': 'Owner user id.'},
            'created_at': {'help_text': 'Creation timestamp.'},
            'updated_at': {'help_text': 'Last update timestamp.'},
        }

    @extend_schema_field(OpenApiTypes.BOOL)
    def get_is_folder(self, obj):
        return obj.is_folder()

    @extend_schema_field(OpenApiTypes.BOOL)
    def get_is_file(self, obj):
        return obj.is_file()

    @extend_schema_field(OpenApiTypes.BOOL)
    def get_is_favorite(self, obj):
        annotated = getattr(obj, 'is_favorite', None)
        if annotated is not None:
            return bool(annotated)
        request = self.context.get('request')
        if not request or not getattr(request, 'user', None) or not request.user.is_authenticated:
            return False
        return FileFavorite.objects.filter(owner=request.user, file=obj).exists()

    @extend_schema_field(OpenApiTypes.STR)
    def get_category(self, obj):
        """Get file category based on MIME type."""
        from .utils import FileTypeDetector

        if obj.node_type != File.NodeType.FILE:
            return None
        return FileTypeDetector.categorize(obj.mime_type or '').value

    @extend_schema_field(OpenApiTypes.BOOL)
    def get_is_viewable(self, obj):
        """Check if file can be viewed in browser."""
        from .utils import FileTypeDetector

        if obj.node_type != File.NodeType.FILE:
            return False
        return FileTypeDetector.is_viewable(obj.mime_type or '')

    @extend_schema_field(OpenApiTypes.STR)
    def get_content_url(self, obj):
        """Get URL to fetch file content for viewing."""
        if obj.node_type == File.NodeType.FILE and obj.content:
            return f'/api/v1/files/{obj.uuid}/content'
        return None

    def validate(self, attrs):
        if self.instance is not None:
            errors = {}
            initial_data = self.initial_data or {}

            if 'uuid' in initial_data:
                incoming_uuid = str(initial_data.get('uuid')).lower()
                if incoming_uuid != str(self.instance.uuid).lower():
                    errors['uuid'] = 'This field is immutable.'

            if 'owner' in initial_data:
                incoming_owner = str(initial_data.get('owner'))
                if incoming_owner != str(self.instance.owner_id):
                    errors['owner'] = 'This field is immutable.'

            if 'node_type' in initial_data:
                if str(initial_data.get('node_type')) != self.instance.node_type:
                    errors['node_type'] = 'This field is immutable.'

            if errors:
                raise serializers.ValidationError(errors)

        node_type = attrs.get('node_type')
        instance = self.instance
        if instance is not None and node_type is None:
            node_type = instance.node_type

        if node_type == File.NodeType.FILE:
            name = attrs.get('name') or (instance.name if instance else None)
            parent = attrs.get('parent') if 'parent' in attrs else (instance.parent if instance else None)
            owner = instance.owner if instance else self.context['request'].user
            if name:
                existing = File.objects.filter(
                    owner=owner,
                    parent=parent,
                    node_type=File.NodeType.FILE,
                    name__iexact=name,
                    deleted_at__isnull=True,
                )
                if instance is not None:
                    existing = existing.exclude(pk=instance.pk)
                if existing.exists():
                    raise serializers.ValidationError({
                        'name': 'A file with the same name already exists in this folder.'
                    })

        return super().validate(attrs)

    def create(self, validated_data):
        validated_data['owner'] = self.context['request'].user
        if validated_data.get('node_type') == File.NodeType.FILE:
            uploaded = validated_data.get('content')
            if uploaded is not None:
                validated_data['size'] = uploaded.size
                if not validated_data.get('mime_type'):
                    validated_data['mime_type'] = self._infer_mime_type(
                        uploaded,
                        validated_data.get('name'),
                    )
        else:
            validated_data['size'] = None
        return super().create(validated_data)

    def _infer_mime_type(self, uploaded, name):
        """Infer mime type from upload metadata or filename."""
        if uploaded is not None:
            content_type = getattr(uploaded, 'content_type', None)
            if content_type and content_type != 'application/octet-stream':
                return content_type
        candidate_name = name or getattr(uploaded, 'name', None)
        if candidate_name:
            guessed, _ = mimetypes.guess_type(candidate_name)
            if guessed:
                return guessed
        return getattr(uploaded, 'content_type', None) or 'application/octet-stream'


    def _get_folder_path(self, folder):
        """Build the full path for a folder based on its hierarchy."""
        path_parts = []
        current = folder
        while current:
            path_parts.insert(0, current.name)
            current = current.parent

        # Add base path: files/username/...
        base_path = f"files/{folder.owner.username}"
        if path_parts:
            return f"{base_path}/{'/'.join(path_parts)}"
        return base_path

    def _rename_folder_files(self, folder, old_folder_name, new_folder_name):
        """Recursively rename all files in a folder and its subfolders."""
        import os
        from django.core.files.storage import default_storage
        from django.core.files.base import ContentFile
        import logging

        logger = logging.getLogger(__name__)

        # Process all children
        children = File.objects.filter(parent=folder)

        for child in children:
            if child.node_type == File.NodeType.FILE and child.content and child.content.name:
                try:
                    old_path = child.content.name

                    # Replace the old folder name with the new one in the path
                    # We need to be careful to replace only the correct occurrence
                    path_segments = old_path.split('/')

                    # Find the index where our folder appears
                    for i, segment in enumerate(path_segments):
                        if segment == old_folder_name:
                            path_segments[i] = new_folder_name
                            break

                    new_path = '/'.join(path_segments)

                    if old_path != new_path:
                        logger.info(f"Moving file from '{old_path}' to '{new_path}'")

                        if default_storage.exists(old_path):
                            # Read the file
                            with default_storage.open(old_path, 'rb') as f:
                                content = f.read()

                            # Ensure directory exists and save to new location
                            new_dir = os.path.dirname(new_path)
                            saved_path = default_storage.save(new_path, ContentFile(content))

                            # Update the database
                            child.content.name = saved_path
                            child.save(update_fields=['content'])

                            # Delete old file
                            try:
                                default_storage.delete(old_path)
                                logger.info(f"Deleted old file: '{old_path}'")
                            except Exception as e:
                                logger.warning(f"Could not delete old file '{old_path}': {e}")
                        else:
                            logger.warning(f"Old file does not exist: '{old_path}'")

                except Exception as e:
                    logger.error(f"Error moving file '{child.name}': {e}")

            elif child.node_type == File.NodeType.FOLDER:
                # Recursively process subfolders
                self._rename_folder_files(child, old_folder_name, new_folder_name)

    def update(self, instance, validated_data):
        """Override update to handle file and folder renaming on storage.

        For files: Renames the physical file on storage.
        For folders: Updates database name AND moves all contained files to new paths.
        """
        import os
        from django.core.files.storage import default_storage
        from django.core.files.base import ContentFile
        import logging

        logger = logging.getLogger(__name__)

        # Handle content update for files
        if 'content' in validated_data:
            uploaded = validated_data.get('content')
            if instance.node_type == File.NodeType.FILE and uploaded is not None:
                validated_data['size'] = uploaded.size
                if not validated_data.get('mime_type'):
                    validated_data['mime_type'] = self._infer_mime_type(
                        uploaded,
                        validated_data.get('name', instance.name),
                    )
                # Note: File replacement is now handled by OverwriteStorage
            else:
                validated_data['size'] = None

        # Check if name is being changed
        if 'name' in validated_data:
            old_name = instance.name
            new_name = validated_data['name']

            if old_name != new_name:
                # Handle folder renaming - move all files inside
                if instance.node_type == File.NodeType.FOLDER:
                    logger.info(f"Renaming folder '{old_name}' to '{new_name}' and moving all contained files")

                    # Rename all files in this folder and subfolders
                    self._rename_folder_files(instance, old_name, new_name)

                # Handle file renaming
                elif instance.content and instance.content.name:
                    try:
                        # Get the current file path
                        old_file_path = instance.content.name

                        # Build the new file path (keep same directory, change filename)
                        dir_path = os.path.dirname(old_file_path)
                        # Get file extension from old file
                        _, ext = os.path.splitext(old_file_path)
                        # Keep extension if new name doesn't have one
                        if '.' not in new_name and ext:
                            new_filename = f"{new_name}{ext}"
                        else:
                            new_filename = new_name
                        new_file_path = os.path.join(dir_path, new_filename)

                        # Check if old file exists
                        if default_storage.exists(old_file_path):
                            # Open and read the old file
                            with default_storage.open(old_file_path, 'rb') as old_file:
                                file_content = old_file.read()

                            # Save with new name
                            new_file_path = default_storage.save(new_file_path, ContentFile(file_content))

                            # Update the content field to point to new file
                            instance.content.name = new_file_path

                            # Delete the old file (only if it's different from the new one)
                            if old_file_path != new_file_path:
                                try:
                                    default_storage.delete(old_file_path)
                                except Exception:
                                    pass  # Ignore delete errors
                    except Exception as e:
                        # Log error but don't fail the rename operation
                        logger.warning(f"Could not rename physical file from {old_file_path} to {new_name}: {e}")

        return super().update(instance, validated_data)
