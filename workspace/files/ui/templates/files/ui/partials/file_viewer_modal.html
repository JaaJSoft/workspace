<!-- File Viewer Modal -->
<div x-data="fileViewerModal()">
  <dialog
    x-ref="dialog"
    class="modal"
    @close="open = false"
  >
    <div
      class="modal-box max-h-[90vh] w-full h-full p-0 flex flex-col relative transition-[max-width] duration-200"
      :class="expanded ? 'max-w-[90vw]' : 'max-w-5xl'"
    >
      <!-- Actions (Top Right) -->
      <div class="absolute top-4 right-4 z-10 flex items-center gap-1">
        <!-- Expand / Collapse -->
        <button
          type="button"
          class="btn btn-ghost btn-sm btn-square"
          @click="toggleExpanded()"
          :title="expanded ? 'Compact view' : 'Expand view'"
          x-show="fileUuid"
        >
          <i x-show="!expanded" data-lucide="maximize-2" class="w-4 h-4"></i>
          <i x-show="expanded" data-lucide="minimize-2" class="w-4 h-4" x-cloak></i>
        </button>

        <!-- Download -->
        <a
          :href="`/api/v1/files/${fileUuid}/content`"
          download
          class="btn btn-ghost btn-sm btn-square"
          title="Download file"
          x-show="fileUuid"
        >
          <i data-lucide="download" class="w-4 h-4"></i>
        </a>

        <!-- Close -->
        <button
          type="button"
          class="btn btn-ghost btn-sm btn-square"
          @click="close()"
          title="Close (ESC)"
        >
          <i data-lucide="x" class="w-4 h-4"></i>
        </button>
      </div>

      <!-- Header -->
      <div class="flex items-center gap-2 p-4 pr-24 border-b border-base-300 bg-base-100">
        <!-- Prev / Next buttons -->
        <div class="flex items-center gap-0.5 shrink-0" x-show="_totalViewable() > 1">
          <button
            type="button"
            class="btn btn-ghost btn-sm btn-square"
            title="Previous file"
            :disabled="_currentIndex() <= 0"
            @click="navigatePrev()"
          >
            <i data-lucide="chevron-left" class="w-4 h-4"></i>
          </button>
          <button
            type="button"
            class="btn btn-ghost btn-sm btn-square"
            title="Next file"
            :disabled="_currentIndex() < 0 || _currentIndex() >= _totalViewable() - 1"
            @click="navigateNext()"
          >
            <i data-lucide="chevron-right" class="w-4 h-4"></i>
          </button>
        </div>

        <div class="flex-1 min-w-0">
          <h3 class="font-bold text-lg truncate" x-text="fileName"></h3>
          <div class="flex items-center gap-2">
            <p class="text-sm text-base-content/60" x-text="mimeType"></p>
            <span
              class="text-xs text-base-content/40"
              x-show="_totalViewable() > 1"
              x-text="(_currentIndex() + 1) + ' / ' + _totalViewable()"
            ></span>
          </div>
        </div>
      </div>

      <!-- Viewer Container -->
      <div
        x-ref="viewerContainer"
        class="flex-1 overflow-auto bg-base-200"
        x-show="!loading && !error"
      >
      </div>

      <!-- Loading State -->
      <div
        x-show="loading"
        class="flex-1 flex items-center justify-center"
        x-cloak
      >
        <span class="loading loading-spinner loading-lg"></span>
      </div>

      <!-- Error State -->
      <div
        x-show="error"
        class="flex-1 flex items-center justify-center p-8"
        x-cloak
      >
        <div class="text-center">
          <i data-lucide="alert-circle" class="w-12 h-12 text-error mx-auto mb-4"></i>
          <p class="text-lg font-medium mb-2">Failed to load file</p>
          <p class="text-sm text-base-content/60" x-text="error"></p>
        </div>
      </div>
    </div>

    <!-- Backdrop -->
    <form method="dialog" class="modal-backdrop">
      <button>close</button>
    </form>
  </dialog>

  <script>
    function fileViewerModal() {
      var VIEWER_PREFS_URL = '/api/v1/settings/files/viewer';
      var _prefsSaveTimer = null;

      function getCSRFToken() {
        var match = document.cookie.split('; ').find(function(row) { return row.startsWith('csrftoken='); });
        return match ? match.split('=')[1] : '';
      }

      return {
        open: false,
        loading: false,
        error: null,
        fileUuid: null,
        fileName: '',
        mimeType: '',
        loadedScripts: [],
        expanded: false,

        _getViewableFiles() {
          var rows = document.querySelectorAll('[data-uuid][data-viewable="1"][data-node-type="file"]');
          return Array.from(rows)
            .filter(function(r) { return r.offsetParent !== null; })
            .map(function(r) {
              return {
                uuid: r.dataset.uuid,
                name: r.dataset.displayName,
                mimeType: r.dataset.mimeType,
              };
            });
        },

        navigateNext() {
          var files = this._getViewableFiles();
          var idx = files.findIndex(f => f.uuid === this.fileUuid);
          if (idx >= 0 && idx < files.length - 1) {
            var next = files[idx + 1];
            this.openFile(next.uuid, next.name, next.mimeType);
          }
        },

        navigatePrev() {
          var files = this._getViewableFiles();
          var idx = files.findIndex(f => f.uuid === this.fileUuid);
          if (idx > 0) {
            var prev = files[idx - 1];
            this.openFile(prev.uuid, prev.name, prev.mimeType);
          }
        },

        _currentIndex() {
          var files = this._getViewableFiles();
          return files.findIndex(f => f.uuid === this.fileUuid);
        },

        _totalViewable() {
          return this._getViewableFiles().length;
        },

        toggleExpanded() {
          this.expanded = !this.expanded;
          this._saveViewerPrefs();
        },

        _saveViewerPrefs() {
          var prefs = { expanded: this.expanded };
          clearTimeout(_prefsSaveTimer);
          _prefsSaveTimer = setTimeout(function() {
            fetch(VIEWER_PREFS_URL, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json', 'X-CSRFToken': getCSRFToken() },
              body: JSON.stringify({ value: prefs }),
            }).catch(function() {});
          }, 500);
        },

        async openFile(uuid, name, mimeType, updateUrl = true) {
          this.fileUuid = uuid;
          this.fileName = name || 'File';
          this.mimeType = mimeType || '';
          this.error = null;

          const container = this.$refs.viewerContainer;

          // Dispatch cleanup event before removing DOM (lets Monaco dispose)
          window.dispatchEvent(new CustomEvent('viewer-cleanup'));

          // Clear previous content and scripts
          container.replaceChildren();
          this.loadedScripts.forEach(script => script.remove());
          this.loadedScripts = [];

          this.loading = true;
          this.open = true;
          this.$refs.dialog.showModal();

          // Update URL with open parameter
          if (updateUrl) {
            const url = new URL(window.location);
            url.searchParams.set('open', uuid);
            window.history.pushState({}, '', url);
          }

          try {
            const response = await fetch(`/files/view/${uuid}`);
            if (!response.ok) {
              throw new Error('Failed to load viewer: ' + response.status);
            }

            const rawHtml = await response.text();

            // Parse HTML with the DOM parser instead of regex
            const temp = document.createElement('template');
            temp.innerHTML = rawHtml;  // same-origin server response

            // Extract and remove script elements from parsed DOM
            const scriptEls = temp.content.querySelectorAll('script');
            const scripts = [];
            scriptEls.forEach(function(el) {
              scripts.push(el.textContent);
              el.remove();
            });

            // Execute scripts first
            scripts.forEach(function(scriptContent) {
              const newScript = document.createElement('script');
              newScript.textContent = scriptContent;
              document.head.appendChild(newScript);
              this.loadedScripts.push(newScript);
            }.bind(this));

            // Move remaining children to container
            while (temp.content.firstChild) {
              container.appendChild(temp.content.firstChild);
            }

            // Reinitialize Lucide icons after content is added
            this.$nextTick(function() {
              if (typeof lucide !== 'undefined') {
                lucide.createIcons();
              }
            });
          } catch (err) {
            this.error = err.message;
          } finally {
            this.loading = false;
          }
        },

        close() {
          // Dispatch cleanup event before removing DOM (lets Monaco dispose)
          window.dispatchEvent(new CustomEvent('viewer-cleanup'));

          this.$refs.dialog.close();
          this.open = false;
          this.fileUuid = null;
          this.fileName = '';
          this.mimeType = '';
          this.error = null;
          // Clear viewer content
          this.$refs.viewerContainer.replaceChildren();
          // Clear loaded scripts
          this.loadedScripts.forEach(script => script.remove());
          this.loadedScripts = [];

          // Remove open parameter from URL
          const url = new URL(window.location);
          url.searchParams.delete('open');
          window.history.pushState({}, '', url);
        },

        handleKeydown(event) {
          if (!this.open) return;

          if (event.key === 'Escape') {
            this.close();
          }

          // Arrow navigation â€” skip if focus is in an editable element
          if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
            var tag = document.activeElement && document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;
            if (document.activeElement && document.activeElement.isContentEditable) return;

            event.preventDefault();
            if (event.key === 'ArrowLeft') {
              this.navigatePrev();
            } else {
              this.navigateNext();
            }
          }
        },

        async init() {
          // Prevent multiple initializations
          if (this._initialized) {
            return;
          }
          this._initialized = true;

          // Load viewer preferences
          try {
            var prefsResp = await fetch(VIEWER_PREFS_URL, { credentials: 'same-origin' });
            if (prefsResp.ok) {
              var data = await prefsResp.json();
              if (data && data.value && typeof data.value === 'object') {
                if (data.value.expanded !== undefined) this.expanded = data.value.expanded;
              }
            }
          } catch (e) {}

          this._keydownHandler = (e) => this.handleKeydown(e);
          this._openFileHandler = (e) => {
            const { uuid, name, mime_type } = e.detail;
            this.openFile(uuid, name, mime_type);
          };

          window.addEventListener('keydown', this._keydownHandler);
          window.addEventListener('open-file-viewer', this._openFileHandler);

          // Handle browser back/forward navigation
          this._popStateHandler = async (event) => {
            const urlParams = new URLSearchParams(window.location.search);
            const fileUuid = urlParams.get('open');

            if (fileUuid && fileUuid !== this.fileUuid) {
              // Open parameter present and different from current - open it
              try {
                const response = await fetch('/api/v1/files/' + fileUuid);
                if (response.ok) {
                  const fileData = await response.json();
                  this.openFile(fileData.uuid, fileData.name, fileData.mime_type, false);
                }
              } catch (err) {
                console.error('Failed to open file from URL:', err);
              }
            } else if (!fileUuid && this.open) {
              // No open parameter but viewer is open - close it
              window.dispatchEvent(new CustomEvent('viewer-cleanup'));
              this.$refs.dialog.close();
              this.open = false;
              this.fileUuid = null;
              this.fileName = '';
              this.mimeType = '';
              this.error = null;
              this.$refs.viewerContainer.replaceChildren();
              this.loadedScripts.forEach(script => script.remove());
              this.loadedScripts = [];
            }
          };
          window.addEventListener('popstate', this._popStateHandler);

          // Check if there's an open parameter in URL and open it
          const urlParams = new URLSearchParams(window.location.search);
          const fileUuid = urlParams.get('open');
          if (fileUuid) {
            try {
              // Fetch file info from API
              const response = await fetch('/api/v1/files/' + fileUuid);
              if (response.ok) {
                const fileData = await response.json();
                // Open file without updating URL (already in URL)
                this.openFile(fileData.uuid, fileData.name, fileData.mime_type, false);
              }
            } catch (err) {
              console.error('Failed to open file from URL:', err);
            }
          }
        }
      };
    }
  </script>
</div>
