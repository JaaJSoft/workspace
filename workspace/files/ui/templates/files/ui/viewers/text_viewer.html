<!-- Monaco DaisyUI theme bridge — overrides inline styles via !important -->
<style>
  .monaco-editor,
  .monaco-editor .monaco-editor-background,
  .monaco-editor .margin {
    background-color: oklch(var(--b2)) !important;
  }
  .monaco-editor .minimap-shadow-visible {
    box-shadow: none !important;
  }
  .monaco-editor .scroll-decoration {
    box-shadow: none !important;
  }
</style>

<!-- Text/Code Viewer with Monaco Editor -->
<div class="flex flex-col h-full"
     x-data="textViewerMonaco()"
     x-init="initEditor()"
     @viewer-cleanup.window="dispose()">

  <!-- Toolbar -->
  <div class="flex items-center justify-between gap-1 px-3 py-1.5 bg-base-100 border-b border-base-300">
    <!-- Left: info -->
    <div class="flex items-center gap-2 min-w-0">
      <span class="badge badge-sm badge-ghost font-mono">{{ language }}</span>
      {% if can_edit %}
      <span x-show="isDirty" x-cloak class="flex items-center gap-1 text-warning text-xs whitespace-nowrap">
        <span class="w-1.5 h-1.5 rounded-full bg-warning inline-block"></span>
        Modified
      </span>
      {% endif %}
    </div>

    <!-- Right: actions -->
    <div class="flex items-center gap-0.5 flex-wrap">
      {% if can_edit %}
      <!-- Undo / Redo -->
      <button type="button" class="btn btn-ghost btn-xs btn-square" @click="editorAction('undo')" title="Undo (Ctrl+Z)">
        <i data-lucide="undo-2" class="w-3.5 h-3.5"></i>
      </button>
      <button type="button" class="btn btn-ghost btn-xs btn-square" @click="editorAction('redo')" title="Redo (Ctrl+Y)">
        <i data-lucide="redo-2" class="w-3.5 h-3.5"></i>
      </button>

      <div class="w-px h-4 bg-base-300 mx-0.5"></div>
      {% endif %}

      <!-- Find / Replace -->
      <button type="button" class="btn btn-ghost btn-xs btn-square" @click="editorAction('find')" title="Find (Ctrl+F)">
        <i data-lucide="search" class="w-3.5 h-3.5"></i>
      </button>
      {% if can_edit %}
      <button type="button" class="btn btn-ghost btn-xs btn-square" @click="editorAction('replace')" title="Replace (Ctrl+H)">
        <i data-lucide="replace" class="w-3.5 h-3.5"></i>
      </button>
      {% endif %}

      <div class="w-px h-4 bg-base-300 mx-0.5"></div>

      <!-- Font size -->
      <button type="button" class="btn btn-ghost btn-xs btn-square" @click="changeFontSize(-1)" title="Decrease font size">
        <i data-lucide="a-arrow-down" class="w-3.5 h-3.5"></i>
      </button>
      <span class="text-xs font-mono w-6 text-center select-none" x-text="fontSize"></span>
      <button type="button" class="btn btn-ghost btn-xs btn-square" @click="changeFontSize(1)" title="Increase font size">
        <i data-lucide="a-arrow-up" class="w-3.5 h-3.5"></i>
      </button>

      <div class="w-px h-4 bg-base-300 mx-0.5"></div>

      <!-- Tab size (cycle 2 → 4 → 8) -->
      <button type="button" class="btn btn-ghost btn-xs gap-0.5 font-mono" @click="cycleTabSize()" title="Tab size (click to cycle)">
        <i data-lucide="indent-increase" class="w-3.5 h-3.5"></i>
        <span class="text-xs" x-text="tabSize"></span>
      </button>

      <div class="w-px h-4 bg-base-300 mx-0.5"></div>

      <!-- Whitespace -->
      <button type="button" class="btn btn-ghost btn-xs btn-square"
              :class="showWhitespace ? 'btn-active' : ''"
              @click="toggleWhitespace()" title="Toggle whitespace characters">
        <i data-lucide="pilcrow" class="w-3.5 h-3.5"></i>
      </button>
      <!-- Line numbers -->
      <button type="button" class="btn btn-ghost btn-xs btn-square"
              :class="lineNumbers ? 'btn-active' : ''"
              @click="toggleLineNumbers()" title="Toggle line numbers">
        <i data-lucide="list-ordered" class="w-3.5 h-3.5"></i>
      </button>
      <!-- Word wrap -->
      <button type="button" class="btn btn-ghost btn-xs btn-square"
              :class="wordWrap ? 'btn-active' : ''"
              @click="toggleWordWrap()" title="Toggle word wrap">
        <i data-lucide="wrap-text" class="w-3.5 h-3.5"></i>
      </button>
      <!-- Minimap -->
      <button type="button" class="btn btn-ghost btn-xs btn-square"
              :class="minimapEnabled ? 'btn-active' : ''"
              @click="toggleMinimap()" title="Toggle minimap">
        <i data-lucide="map" class="w-3.5 h-3.5"></i>
      </button>

      {% if ai_enabled %}
      <div class="w-px h-4 bg-base-300 mx-0.5"></div>

      <!-- AI Actions -->
      <div class="dropdown dropdown-end">
        <label tabindex="0" class="btn btn-ghost btn-xs gap-1" :class="aiProcessing ? 'btn-disabled' : ''">
          <span x-show="aiProcessing" class="loading loading-spinner loading-xs"></span>
          <i x-show="!aiProcessing" data-lucide="sparkles" class="w-3.5 h-3.5"></i>
          AI
          <i data-lucide="chevron-down" class="w-3 h-3"></i>
        </label>
        <ul tabindex="0" class="dropdown-content z-50 menu menu-sm shadow-xl bg-base-100 border border-base-300 rounded-lg w-52 p-1 mt-2">
          <li>
            <button type="button" class="gap-3 rounded" @click="aiAction('improve'); document.activeElement.blur()">
              <i data-lucide="wand-2" class="w-4 h-4"></i>
              <span>Improve</span>
            </button>
          </li>
          <li>
            <button type="button" class="gap-3 rounded" @click="aiAction('explain'); document.activeElement.blur()">
              <i data-lucide="message-square-text" class="w-4 h-4"></i>
              <span>Explain</span>
            </button>
          </li>
          <li>
            <button type="button" class="gap-3 rounded" @click="aiAction('summarize'); document.activeElement.blur()">
              <i data-lucide="list" class="w-4 h-4"></i>
              <span>Summarize</span>
            </button>
          </li>
          <hr class="my-1 border-base-300" />
          <li>
            <button type="button" class="gap-3 rounded" @click="aiAction('custom'); document.activeElement.blur()">
              <i data-lucide="pencil" class="w-4 h-4"></i>
              <span>Custom prompt...</span>
            </button>
          </li>
        </ul>
      </div>
      {% endif %}

      {% if can_edit %}
      <div class="w-px h-4 bg-base-300 mx-0.5"></div>

      <!-- Save -->
      <button type="button" class="btn btn-primary btn-xs"
              :disabled="!isDirty || saving"
              @click="save()" title="Save (Ctrl+S)">
        <span x-show="saving" class="loading loading-spinner loading-xs"></span>
        <i x-show="!saving" data-lucide="save" class="w-3.5 h-3.5"></i>
        Save
      </button>
      {% endif %}
    </div>
  </div>

  <!-- Lock banner -->
  <div x-show="lockOwner" x-cloak
       class="flex items-center gap-2 px-3 py-2 bg-warning/10 border-b border-warning/30 text-warning-content text-sm">
    <i data-lucide="lock" class="w-4 h-4 text-warning shrink-0"></i>
    <span class="flex-1"><strong x-text="lockOwner"></strong> is editing this file</span>
    <button type="button" class="btn btn-warning btn-xs" @click="forceUnlock()">Force unlock</button>
  </div>

  <!-- Monaco Container -->
  <div x-ref="monacoContainer" class="flex-1 min-h-0"></div>
</div>

<script>
window.textViewerMonaco = function() {
  // Keep complex objects OUT of Alpine's reactive scope
  let _editor = null;
  let _themeObserver = null;
  let _prefsSaveTimer = null;
  let _lock = null;
  let _aiPollTimer = null;

  var PREFS_URL = '/api/v1/settings/files/editor';
  var PREFS_DEFAULTS = {
    wordWrap: true,
    minimap: true,
    fontSize: 14,
    tabSize: 2,
    showWhitespace: false,
    lineNumbers: true,
  };

  function getCSRFToken() {
    var match = document.cookie.split('; ').find(function(row) { return row.startsWith('csrftoken='); });
    return match ? match.split('=')[1] : '';
  }

  function savePrefsRemote(prefs) {
    clearTimeout(_prefsSaveTimer);
    _prefsSaveTimer = setTimeout(function() {
      fetch(PREFS_URL, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': getCSRFToken() },
        body: JSON.stringify({ value: prefs }),
      }).catch(function() {});
    }, 500);
  }

  function _detectTheme() {
    var dt = (document.documentElement.getAttribute('data-theme') || '').toLowerCase();
    var dark = ['dark','dracula','night','sunset','dim','black','luxury','halloween','forest','coffee','business','synthwave'];
    return dark.some(function(t) { return dt.includes(t); }) ? 'vs-dark' : 'vs';
  }

  function _attachEditHandlers(self) {
    _editor.onDidChangeModelContent(function() {
      self.isDirty = _editor.getValue() !== self.originalContent;
    });
    _editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS, function() {
      self.save();
    });
  }

  return {
    isDirty: false,
    saving: false,
    aiProcessing: false,
    wordWrap: PREFS_DEFAULTS.wordWrap,
    minimapEnabled: PREFS_DEFAULTS.minimap,
    fontSize: PREFS_DEFAULTS.fontSize,
    tabSize: PREFS_DEFAULTS.tabSize,
    showWhitespace: PREFS_DEFAULTS.showWhitespace,
    lineNumbers: PREFS_DEFAULTS.lineNumbers,
    canEdit: {{ can_edit|yesno:'true,false' }},
    originalContent: '{{ content|escapejs }}',
    fileUuid: '{{ file.uuid }}',
    fileName: '{{ file.name }}',
    language: '{{ language }}',
    lockOwner: {% if lock_info %}'{{ lock_info.locked_by_username|escapejs }}'{% else %}null{% endif %},

    initEditor() {
      var container = this.$refs.monacoContainer;
      var content = this.originalContent;
      var language = this.language;
      var self = this;
      _lock = window.fileLock(this.fileUuid, getCSRFToken);

      fetch(PREFS_URL, { credentials: 'same-origin' })
        .then(function(r) { return r.ok ? r.json() : null; })
        .then(function(data) {
          if (data && data.value && typeof data.value === 'object') {
            var v = data.value;
            self.wordWrap = v.wordWrap !== undefined ? v.wordWrap : PREFS_DEFAULTS.wordWrap;
            self.minimapEnabled = v.minimap !== undefined ? v.minimap : PREFS_DEFAULTS.minimap;
            self.fontSize = v.fontSize !== undefined ? v.fontSize : PREFS_DEFAULTS.fontSize;
            self.tabSize = v.tabSize !== undefined ? v.tabSize : PREFS_DEFAULTS.tabSize;
            self.showWhitespace = v.showWhitespace !== undefined ? v.showWhitespace : PREFS_DEFAULTS.showWhitespace;
            self.lineNumbers = v.lineNumbers !== undefined ? v.lineNumbers : PREFS_DEFAULTS.lineNumbers;
          }
        })
        .catch(function() {})
        .finally(function() {
          self._createEditor(container, content, language);
        });
    },

    _createEditor(container, content, language) {
      var self = this;

      if (!window._monacoConfigured) {
        require.config({ paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs' } });
        window._monacoConfigured = true;
      }

      require(['vs/editor/editor.main'], function() {
        if (!window.MonacoEnvironment) {
          window.MonacoEnvironment = {
            getWorkerUrl: function() {
              return 'data:text/javascript;charset=utf-8,' + encodeURIComponent(
                'self.MonacoEnvironment = { baseUrl: "https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/" };'
                + 'importScripts("https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/base/worker/workerMain.js");'
              );
            }
          };
        }

        _editor = monaco.editor.create(container, {
          value: content,
          language: language,
          theme: _detectTheme(),
          readOnly: !self.canEdit || !!self.lockOwner,
          minimap: { enabled: self.minimapEnabled },
          wordWrap: self.wordWrap ? 'on' : 'off',
          fontSize: self.fontSize,
          tabSize: self.tabSize,
          insertSpaces: true,
          renderWhitespace: self.showWhitespace ? 'all' : 'selection',
          lineNumbers: self.lineNumbers ? 'on' : 'off',
          automaticLayout: true,
          scrollBeyondLastLine: false,
          smoothScrolling: true,
          cursorBlinking: 'smooth',
          padding: { top: 8, bottom: 8 },
        });

        if (self.canEdit && !self.lockOwner) {
          _attachEditHandlers(self);
        }

        _themeObserver = new MutationObserver(function() {
          monaco.editor.setTheme(_detectTheme());
        });
        _themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ['data-theme']
        });

        // Acquire lock (or listen for release) after editor is ready
        if (self.canEdit) {
          _lock.acquire(self, {
            onLocked: function() { if (_editor) _editor.updateOptions({ readOnly: true }); },
            onAcquired: function() {
              if (_editor) {
                _editor.updateOptions({ readOnly: false });
                _attachEditHandlers(self);
              }
            },
          });
        }
      });
    },

    forceUnlock() {
      var self = this;
      _lock.forceUnlock(self, {
        onAcquired: function() {
          if (_editor) {
            _editor.updateOptions({ readOnly: false });
            _attachEditHandlers(self);
          }
        },
      });
    },

    _currentPrefs() {
      return {
        wordWrap: this.wordWrap,
        minimap: this.minimapEnabled,
        fontSize: this.fontSize,
        tabSize: this.tabSize,
        showWhitespace: this.showWhitespace,
        lineNumbers: this.lineNumbers,
      };
    },

    _persistPrefs() {
      savePrefsRemote(this._currentPrefs());
    },

    editorAction(action) {
      if (!_editor) return;
      var actionMap = {
        undo: 'undo',
        redo: 'redo',
        find: 'actions.find',
        replace: 'editor.action.startFindReplaceAction',
      };
      _editor.trigger('toolbar', actionMap[action]);
      _editor.focus();
    },

    changeFontSize(delta) {
      var next = Math.min(32, Math.max(8, this.fontSize + delta));
      if (next === this.fontSize) return;
      this.fontSize = next;
      if (_editor) _editor.updateOptions({ fontSize: this.fontSize });
      this._persistPrefs();
    },

    cycleTabSize() {
      var sizes = [2, 4, 8];
      var idx = sizes.indexOf(this.tabSize);
      this.tabSize = sizes[(idx + 1) % sizes.length];
      if (_editor) {
        _editor.getModel().updateOptions({ tabSize: this.tabSize });
      }
      this._persistPrefs();
    },

    toggleWhitespace() {
      this.showWhitespace = !this.showWhitespace;
      if (_editor) _editor.updateOptions({ renderWhitespace: this.showWhitespace ? 'all' : 'selection' });
      this._persistPrefs();
    },

    toggleLineNumbers() {
      this.lineNumbers = !this.lineNumbers;
      if (_editor) _editor.updateOptions({ lineNumbers: this.lineNumbers ? 'on' : 'off' });
      this._persistPrefs();
    },

    toggleWordWrap() {
      this.wordWrap = !this.wordWrap;
      if (_editor) _editor.updateOptions({ wordWrap: this.wordWrap ? 'on' : 'off' });
      this._persistPrefs();
    },

    toggleMinimap() {
      this.minimapEnabled = !this.minimapEnabled;
      if (_editor) _editor.updateOptions({ minimap: { enabled: this.minimapEnabled } });
      this._persistPrefs();
    },

    async save() {
      if (!_editor || this.saving || !this.isDirty) return;
      this.saving = true;

      try {
        var content = _editor.getValue();
        var blob = new Blob([content], { type: 'text/plain' });
        var formData = new FormData();
        formData.append('content', blob, this.fileName || 'file.txt');

        var response = await fetch('/api/v1/files/' + this.fileUuid, {
          method: 'PATCH',
          headers: { 'X-CSRFToken': getCSRFToken() },
          body: formData,
        });

        if (!response.ok) throw new Error('Failed to save');

        this.originalContent = content;
        this.isDirty = false;

        if (window.AppAlert) {
          window.AppAlert.success('File saved successfully');
        }
      } catch (error) {
        console.error('Failed to save file:', error);
        if (window.AppAlert) {
          window.AppAlert.error('Failed to save: ' + error.message);
        }
      } finally {
        this.saving = false;
      }
    },

    _getEditorContent() {
      if (!_editor) return null;
      var selection = _editor.getSelection();
      if (selection && !selection.isEmpty()) {
        return {
          text: _editor.getModel().getValueInRange(selection),
          range: selection,
        };
      }
      var model = _editor.getModel();
      return {
        text: model.getValue(),
        range: model.getFullModelRange(),
      };
    },

    async aiAction(action) {
      if (!_editor || this.aiProcessing) return;

      var instructions = '';
      if (action === 'custom') {
        instructions = await AppDialog.prompt({
          title: 'Custom AI Prompt',
          message: 'What would you like AI to do with the selected content?',
          placeholder: 'e.g. Translate to French, Add comments, Refactor...',
          okLabel: 'Run',
          icon: 'sparkles',
        });
        if (!instructions) return;
      }

      var content = this._getEditorContent();
      if (!content || !content.text.trim()) {
        if (window.AppAlert) AppAlert.error('No content to process');
        return;
      }

      this.aiProcessing = true;

      try {
        var body = {
          action: action,
          content: content.text,
          language: this.language,
          filename: this.fileName,
        };
        if (instructions) body.instructions = instructions;

        var response = await fetch('/api/v1/ai/tasks/editor', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCSRFToken(),
          },
          body: JSON.stringify(body),
        });

        if (!response.ok) {
          var err = await response.json().catch(function() { return {}; });
          throw new Error(err.detail || 'Failed to start AI task');
        }

        var task = await response.json();
        this._pollAITask(task.uuid, action, content.range);
      } catch (error) {
        this.aiProcessing = false;
        if (window.AppAlert) AppAlert.error('AI error: ' + error.message);
      }
    },

    _pollAITask(taskId, action, editRange) {
      var self = this;
      _aiPollTimer = setInterval(async function() {
        try {
          var response = await fetch('/api/v1/ai/tasks/' + taskId, {
            credentials: 'same-origin',
          });
          if (!response.ok) throw new Error('Failed to poll task');

          var task = await response.json();

          if (task.status === 'completed') {
            clearInterval(_aiPollTimer);
            _aiPollTimer = null;
            self._handleAIResult(action, task.result, task.result_html, editRange);
            self.aiProcessing = false;
          } else if (task.status === 'failed') {
            clearInterval(_aiPollTimer);
            _aiPollTimer = null;
            self.aiProcessing = false;
            if (window.AppAlert) AppAlert.error('AI failed: ' + (task.error || 'Unknown error'));
          }
        } catch (error) {
          clearInterval(_aiPollTimer);
          _aiPollTimer = null;
          self.aiProcessing = false;
          if (window.AppAlert) AppAlert.error('AI error: ' + error.message);
        }
      }, 2000);
    },

    _handleAIResult(action, result, resultHtml, editRange) {
      if (!result) return;
      if (action === 'explain' || action === 'summarize') {
        var title = action === 'explain' ? 'Explanation' : 'Summary';
        var icon = action === 'explain' ? 'message-square-text' : 'list';
        AppDialog.message({
          title: title,
          html: '<div class="prose prose-sm max-w-none">' + (resultHtml || result) + '</div>',
          icon: icon,
          iconClass: 'bg-primary/10 text-primary',
        });
      } else {
        if (!_editor) return;
        _editor.pushUndoStop();
        _editor.executeEdits('ai-action', [{
          range: editRange,
          text: result,
          forceMoveMarkers: true,
        }]);
        _editor.pushUndoStop();
        _editor.focus();
      }
    },

    dispose() {
      if (_lock) _lock.dispose();
      clearTimeout(_prefsSaveTimer);
      clearInterval(_aiPollTimer);
      if (_themeObserver) {
        _themeObserver.disconnect();
        _themeObserver = null;
      }
      if (_editor) {
        _editor.dispose();
        _editor = null;
      }
    },
  };
};
</script>
